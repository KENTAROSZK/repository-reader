--- ディレクトリ構造 ---
repository-reader
├── context
│   ├── cpu
│   │   └── docker-compose.yaml
│   └── Dockerfile
├── experimentation
│   └── rag.py
├── project_module
│   └── src
│       └── project_module
│           ├── directory_lister
│           │   ├── temp_lister_test
│           │   │   ├── dir_a
│           │   │   ├── dir_c
│           │   │   ├── File_B.py
│           │   │   └── file_z.txt
│           │   ├── config.py
│           │   ├── directory_lister.py
│           │   └── settings.yml
│           └── __init__.py
├── .gitignore
├── pyproject.toml
├── README.md
└── Taskfile.yaml


--- ファイル内容 ---


/.gitignore:
--------------------------------------------------------------------------------
1 | # 環境変数
2 | .env*
3 | env/
4 | 
5 | .local*
--------------------------------------------------------------------------------


/context/cpu/docker-compose.yaml:
--------------------------------------------------------------------------------
 1 | services:
 2 |   python-dev: # サービス名 (任意)
 3 |     build:
 4 |       context: ../../context/
 5 |       dockerfile: Dockerfile
 6 |       args:
 7 |         POETRY_VERSION: ${POETRY_VERSION}
 8 |         POETRY_HOME: ${POETRY_HOME}
 9 |         USER_UID: ${USER_UID}
10 |         USERNAME: ${USERNAME}
11 |         PROJECT_NAME: ${PROJECT_NAME}
12 |     container_name: ${CONTAINER_NAME}
13 |     volumes:
14 |       - type: bind
15 |         source: ../../
16 |         target: /home/${USERNAME}/${PROJECT_NAME}
17 |     working_dir: /home/${USERNAME}/${PROJECT_NAME}
18 |     tty: true
19 |     restart: always # コンテナが停止した場合に常に再起動する
--------------------------------------------------------------------------------


/context/Dockerfile:
--------------------------------------------------------------------------------
 1 | FROM python:3.11-slim
 2 | 
 3 | # Build-time arguments
 4 | ARG POETRY_VERSION
 5 | ARG POETRY_HOME
 6 | ARG USER_UID
 7 | ARG USERNAME
 8 | ARG PROJECT_NAME
 9 | 
10 | # 必要なパッケージをインストール（curl等）
11 | RUN apt-get update && apt-get install -y --no-install-recommends \
12 |     curl \
13 |     && apt-get clean \
14 |     && rm -rf /var/lib/apt/lists/*
15 | 
16 | # Poetryのインストール
17 | RUN echo ${POETRY_HOME}
18 | SHELL ["/bin/bash", "-o", "pipefail", "-c"]
19 | RUN curl -sSL https://install.python-poetry.org/ | python3 - --version ${POETRY_VERSION} && \
20 |     ln -s ${POETRY_HOME}/bin/poetry /usr/local/bin/poetry
21 | 
22 | # Node.jsとnpmのインストール
23 | RUN curl -fsSL https://deb.nodesource.com/setup_18.x | bash - && \
24 | apt-get install -y --no-install-recommends nodejs && \
25 | apt-get clean && \
26 | rm -rf /var/lib/apt/lists/*
27 | 
28 | 
29 | # ==========================================
30 | # Create user in the container to avoid permission matter
31 | # incompatible between host and container user
32 | # ==========================================
33 | RUN useradd --uid ${USER_UID} -m ${USERNAME}
34 | 
35 | USER $USERNAME
36 | ENV PATH="/usr/local/bin:$PATH"
37 | 
38 | 
39 | WORKDIR /home/${USERNAME}/${PROJECT_NAME}
--------------------------------------------------------------------------------


/experimentation/rag.py:
--------------------------------------------------------------------------------
1 | rag.py
--------------------------------------------------------------------------------


/project_module/src/project_module/__init__.py:
--------------------------------------------------------------------------------
 [空ファイル]
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/config.py:
--------------------------------------------------------------------------------
 1 | import yaml
 2 | from pydantic import BaseModel
 3 | from typing import List
 4 | from pathlib import Path
 5 | 
 6 | class IgnoreExtensionsConfig(BaseModel):
 7 |     images: List[str] | None
 8 |     videos: List[str] | None
 9 |     compressed: List[str] | None
10 |     binaries: List[str] | None
11 |     documents: List[str] | None
12 |     others: List[str] | None
13 | 
14 |     def all_extensions(self) -> List[str]:
15 |         """全ての拡張子を取得する"""
16 |         all_exts = []
17 |         for attr in self.__dict__.values():
18 |             if isinstance(attr, list):
19 |                 all_exts.extend(attr)
20 |         return all_exts
21 | 
22 | 
23 | 
24 | class Config(BaseModel):
25 |     ignore_dirs: List[str] | None
26 |     ignore_files: List[str] | None
27 |     ignore_extensions: IgnoreExtensionsConfig | None
28 | 
29 | 
30 | def get_config(settings_yaml_path: Path)->Config:
31 |     with open(settings_yaml_path, 'rb') as f:
32 |         yml = yaml.safe_load(f)
33 | 
34 |     return Config.model_validate(yml)
35 | 
36 | 
37 | def main() -> None:
38 |     settings_yaml_path = Path('./settings.yml')
39 |     config = get_config(settings_yaml_path)
40 | 
41 |     print()
42 |     print(f"{getattr(config, 'ignore_dirs')=}")
43 |     print()
44 |     print(f"{getattr(config, 'ignore_extensions')=}")
45 |     print()
46 |     print(f"{getattr(config.ignore_extensions, 'images')=}")
47 |     print()
48 |     print(config.ignore_extensions.all_extensions())
49 |     print()
50 | 
51 | 
52 | if __name__ == "__main__":
53 |     main()
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/directory_lister.py:
--------------------------------------------------------------------------------
  1 | from pathlib import Path
  2 | from typing import List
  3 | from config import get_config, Config
  4 | 
  5 | import os
  6 | import sys
  7 | 
  8 | 
  9 | class DirectoryLister:
 10 |     def __init__(
 11 |             self,
 12 |             directory_path: Path,
 13 |             output_file: Path,
 14 |             config: Config
 15 |     ):
 16 |         self.root_path = directory_path.resolve() # 絶対パスに変換
 17 |         self.output_file = output_file
 18 |         self.config = config
 19 | 
 20 |         if not self.root_path.is_dir():
 21 |             raise ValueError(f"{self.root_path} is not a directory.")
 22 | 
 23 |         self.ignore_dirs = getattr(self.config, "ignore_dirs")
 24 |         self.ignore_files = getattr(self.config, "ignore_files")
 25 |         self.ignore_extensions = getattr(self.config.ignore_extensions, "all_extensions")()
 26 |         self.ignore_files.append(str(output_file)) # 過去に出力したテキストを無視する必要がある
 27 | 
 28 | 
 29 |     def _should_ignore(self, path: Path) -> bool:
 30 |         """指定されたパスが無視対象かどうかを判定する"""
 31 |         if any(part in self.ignore_dirs for part in path.parts): return True # ディレクトリ名で無視
 32 |         if path.name in self.ignore_files: return True # ファイル名で無視
 33 |         if path.suffix.lower() in self.ignore_extensions: return True # 拡張子で無視
 34 | 
 35 |         return False
 36 | 
 37 | 
 38 |     def _get_sorted_items(self, directory: Path) -> List[Path]:
 39 |         """指定されたディレクトリ内のアイテムを無視対象を除外してソートする. 内部メソッド"""
 40 |         # TODO: パーミッションエラーやディレクトリを見つけられなかった時のエラーハンドリングを追加する
 41 | 
 42 |         # ディレクトリ内のアイテムを取得し、無視対象を除外してソート
 43 |         filtered_items = [item for item in directory.iterdir() if not self._should_ignore(item)]
 44 |         items = sorted(
 45 |             filtered_items,
 46 |             key=lambda x: (x.is_file(), x.name.lower()) # ディレクトリを先に、次にファイル名でソート
 47 |         )
 48 |         return items
 49 | 
 50 | 
 51 |     def _generate_tree_recursive(
 52 |             self,
 53 |             current_path: Path,
 54 |             prefix: str = "",
 55 |             is_last: bool=True
 56 |     ) -> str:
 57 |         """ディレクトリ構造をtree形式で再帰的に生成する（内部メソッド）"""
 58 |         structure = ""
 59 |         connector = '└── ' if is_last else '├── '
 60 | 
 61 |         try:
 62 |             structure += f"{prefix}{connector}{current_path.name}\n"
 63 | 
 64 |             # ディレクトリの場合は再起的に呼び出す
 65 |             if current_path.is_dir():
 66 |                 new_prefix = prefix + ('    ' if is_last else '│   ')
 67 |                 # サブアイテムを取得する
 68 |                 items = self._get_sorted_items(current_path)
 69 |                 item_count = len(items)
 70 | 
 71 |                 for i, item in enumerate(items):
 72 |                     is_last_item= (i == item_count - 1)
 73 |                     # 再帰的に呼び出す
 74 |                     structure += self._generate_tree_recursive(item, new_prefix, is_last_item)
 75 | 
 76 |         except OSError as e:
 77 |             structure += f"{prefix}{connector}[エラー: {e.strerror} ({current_path.name})]\n"
 78 |         except Exception as e:
 79 |             structure += f"{prefix}{connector}[予期せぬエラー: {e} ({current_path.name})]\n"
 80 | 
 81 |         return structure
 82 | 
 83 | 
 84 |     def generate_tree_structure(self)-> str:
 85 |         """ルートディレクトリから始まる全体のディレクt理構造の文字列を生成する"""
 86 |         structure = f"{self.root_path.name}\n"
 87 |         print(structure)
 88 | 
 89 |         # ルートディレクトリのアイテムを取得
 90 |         items = self._get_sorted_items(self.root_path)
 91 | 
 92 |         # 各アイテムに対して再起的に処理をする
 93 |         num_items = len(items)
 94 |         for i, item in enumerate(items):
 95 |             is_last_item = (i == num_items - 1)
 96 |             structure += self._generate_tree_recursive(item, "", is_last_item) # prefixは空文字列で初期化
 97 | 
 98 |         return structure
 99 | 
100 | 
101 |     def _format_file_content(self, file_path: Path) -> str:
102 |         """単一のファイルのパスと内容を読み込み、整形して文字列で返す。 内部メソッド"""
103 | 
104 |         content_str = "" # 結果の文字列
105 |         separator = "-" * 80 + "\n" # 区切り線の定義
106 | 
107 |         # 相対パスの取得
108 |         relative_path = file_path.relative_to(self.root_path) # 相対パスを取得
109 |         content_str += f"\n\n/{relative_path}:\n" # 相対パスを表示
110 | 
111 |         content_str += separator
112 | 
113 |         # ファイルの内容を読み込む
114 |         try:
115 |             with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
116 |                 lines = f.readlines() # ファイルの全行をリストとして読み込む
117 | 
118 |             if not lines: # 空ファイルの場合
119 |                 content_str += " [空ファイル]\n"
120 |             else:
121 |                 max_digits = len(str(len(lines))) # 行番号の桁数を計算。仮に20行であればmax_digitsは2になる。
122 |                 for i, line in enumerate(lines):
123 |                     line_num_str = str(i+1).rjust(max_digits) # 行番号を右寄せで整形
124 |                     content_str += f"{line_num_str} | {line.rstrip()}\n" # 行末の改行文字（rstrip()）を除去して、整形して追加
125 |         except PermissionError:
126 |             content_str += f" [エラー] ファイル '{file_path.name}' へのアクセス権がありません。\n"
127 |         except OSError as e:
128 |             content_str += f" [エラー] ファイル '{file_path.name}' 読み込み中にOSエラーが発生しました: {e.strerror}\n"
129 |         except Exception as e:
130 |             content_str += f" [エラー] ファイル '{file_path.name}' 読み込み中に予期せぬエラーが発生しました: {e}\n"
131 | 
132 |         content_str += separator # 最後に区切り線を追加
133 |         return content_str
134 | 
135 | 
136 |     def generate_file_contents(self)->str:
137 |         """全ファイルのパスと内容を行番号付きで取得する"""
138 |         contents=""
139 | 
140 |         files = [os.path.join(dirpath, f) for dirpath, _, filenames in os.walk(self.root_path) for f in filenames]
141 |         files = [item for item in files if not self._should_ignore(Path(item))] # 無視対象を除外
142 |         files = sorted(files, key=lambda x: (os.path.isfile(x), x.lower())) # ディレクトリを先に、次にファイル名でソート
143 |         files = [Path(item) for item in files] # Pathオブジェクトに変換
144 | 
145 |         for file in files:
146 |             contents += self._format_file_content(file)
147 | 
148 |         return contents
149 | 
150 | 
151 |     def write_to_file(self, tree_structure: str, file_contents: str) -> None:
152 |         """
153 |         生成したディレクトリ構造とファイル内容を指定されたファイルに書き込む。
154 | 
155 |         Args:
156 |             tree_structure (str): generate_tree_structureで生成された文字列。
157 |             file_contents (str): generate_file_contentsで生成された文字列。
158 |         """
159 |         print(f"ファイル '{self.output_file}' に書き込み中...")
160 |         try:
161 |             # --- 出力ファイルの親ディレクトリが存在しない場合に作成 ---
162 |             # self.output_path.parent は出力ファイルの親ディレクトリのPathオブジェクト
163 |             # parents=True: 中間ディレクトリもまとめて作成 (例: /a/b/c.txt で a, b がなくても作る)
164 |             # exist_ok=True: ディレクトリが既に存在していてもエラーにしない
165 |             self.output_file.parent.mkdir(parents=True, exist_ok=True)
166 | 
167 |             # --- ファイルへの書き込み ---
168 |             # 'w'モード: 書き込みモード。ファイルが存在すれば上書き、なければ新規作成。
169 |             # encoding='utf-8': UTF-8エンコーディングで書き込む。
170 |             with open(self.output_file, 'w', encoding='utf-8') as f:
171 |                 f.write("--- ディレクトリ構造 ---\n")
172 |                 f.write(tree_structure)
173 |                 f.write("\n\n--- ファイル内容 ---\n") # 構造と内容の間に区切りを入れる
174 |                 f.write(file_contents)
175 | 
176 |             # 成功メッセージ (絶対パスで表示すると分かりやすい)
177 |             print(f"ディレクトリリストが '{self.output_file.resolve()}' に出力されました。")
178 | 
179 |         except IOError as e:
180 |             # ファイル書き込みに関するエラー (ディスクフル、アクセス権など)
181 |             print(f"エラー: ファイル '{self.output_file}' に書き込めませんでした: {e}", file=sys.stderr)
182 |         except Exception as e:
183 |             # その他の予期せぬエラー
184 |             print(f"予期せぬエラーが発生しました: {e}", file=sys.stderr)
185 |     def run(self) -> None:
186 |         """
187 |         ディレクトリリスト化の全処理を実行する。
188 |         """
189 |         print(f"処理を開始します: {self.root_path}")
190 |         try:
191 |             # 1. ディレクトリ構造を生成
192 |             tree_structure = self.generate_tree_structure()
193 | 
194 |             # 2. ファイル内容を生成
195 |             file_contents = self.generate_file_contents()
196 | 
197 |             # 3. ファイルに書き込み
198 |             self.write_to_file(tree_structure, file_contents)
199 | 
200 |             print("処理が正常に完了しました。")
201 | 
202 |         except Exception as e:
203 |             # run の中で予期せぬエラーが起きた場合 (各メソッド内で捕捉されなかった場合など)
204 |             print(f"\n処理中にエラーが発生しました: {e}", file=sys.stderr)
205 |             # ここでプログラムを終了させるか、呼び出し元にエラーを伝えるかは設計による
206 |             # 今回は呼び出し元 (mainブロック) で最終的なエラーハンドリングを行う想定
207 |             raise # 捕捉したエラーを再度送出する
208 | 
209 | 
210 | def test_should_ignore(lister: DirectoryLister) -> None:
211 |     # テスト用のPathオブジェクトを作成 (Windows/Mac/Linuxで互換性のある書き方)
212 |     test_path_git = Path(".git") / "config" # 相対パスで作成
213 |     test_path_pycache = Path("my_module") / "__pycache__" / "cache_file.pyc"
214 |     test_path_dsstore = Path("images") / ".DS_Store"
215 |     test_path_log = Path("logs") / "app.log"
216 |     test_path_normal_file = Path("src") / "main.py"
217 |     test_path_normal_dir = Path("data")
218 |     test_path_root_ignored_file = Path(".env")
219 |     test_path_image = Path("assets") / "logo.png"
220 | 
221 |     print("-" * 20)
222 |     print("無視判定テスト:")
223 |     print(f"'{test_path_git}' は無視対象? -> {lister._should_ignore(test_path_git)}") # Trueのはず
224 |     print(f"'{test_path_pycache}' は無視対象? -> {lister._should_ignore(test_path_pycache)}") # Trueのはず
225 |     print(f"'{test_path_dsstore}' は無視対象? -> {lister._should_ignore(test_path_dsstore)}") # Trueのはず
226 |     print(f"'{test_path_log}' は無視対象? -> {lister._should_ignore(test_path_log)}") # Trueのはず
227 |     print(f"'{test_path_normal_file}' は無視対象? -> {lister._should_ignore(test_path_normal_file)}") # Falseのはず
228 |     print(f"'{test_path_normal_dir}' は無視対象? -> {lister._should_ignore(test_path_normal_dir)}") # Falseのはず
229 |     print(f"'{test_path_root_ignored_file}' は無視対象? -> {lister._should_ignore(test_path_root_ignored_file)}") # Trueのはず
230 |     print(f"'{test_path_image}' は無視対象? -> {lister._should_ignore(test_path_image)}") # Trueのはず
231 |     print("-" * 20)
232 | 
233 | 
234 | def test_get_sorted_items() -> None:
235 |     # テスト用のディレクトリとファイルを作成
236 |     test_base_dir = Path("./temp_lister_test")
237 |     test_base_dir.mkdir(exist_ok=True)
238 |     (test_base_dir / "dir_a").mkdir(exist_ok=True)
239 |     (test_base_dir / "file_z.txt").touch(exist_ok=True)
240 |     (test_base_dir / "File_B.py").touch(exist_ok=True)
241 |     (test_base_dir / "dir_c").mkdir(exist_ok=True)
242 |     (test_base_dir / ".env").touch(exist_ok=True) # 無視されるファイル
243 |     (test_base_dir / "image.png").touch(exist_ok=True) # 無視される拡張子
244 |     (test_base_dir / ".git").mkdir(exist_ok=True) # 無視されるディレクトリ
245 | 
246 |     # Listerインスタンスを作成 (テストディレクトリを対象)
247 |     lister = DirectoryLister(
248 |         Path(test_base_dir),
249 |         Path("./output.txt"),
250 |         config=get_config(Path('./settings.yml'))
251 |     )
252 | 
253 |     print(f"\n'{test_base_dir}' 内のソート済みアイテム:")
254 |     sorted_items = lister._get_sorted_items(test_base_dir)
255 |     if not sorted_items:
256 |         print("  (アイテムが見つからないか、アクセスエラー)")
257 |     for item in sorted_items:
258 |         item_type = "Dir " if item.is_dir() else "File"
259 |         print(f"  {item_type}: {item.name}")
260 | 
261 |     # 期待される出力順序の確認 (手動)
262 |     # dir_a, dir_c, File_B.py, file_z.txt の順になるはず
263 | 
264 | 
265 | def main() -> None:
266 | 
267 |     ROOT_DIR = Path(__file__).resolve().parent.parent.parent.parent.parent# プロジェクトのルートディレクトリを取得
268 |     sys.path.append(str(ROOT_DIR)) # sys.pathに追加してインポート可能にする
269 | 
270 |     # インスタンス化
271 |     lister = DirectoryLister(
272 |         directory_path=Path(ROOT_DIR),
273 |         output_file=Path('./text.txt'),
274 |         config=get_config(Path('./settings.yml'))
275 |     )
276 | 
277 |     # ディレクトリリスト化を実行
278 |     lister.run()
279 | 
280 | 
281 |     # for item in a:
282 |     #     print(item)
283 | 
284 |     # test_should_ignore(lister)
285 |     # test_get_sorted_items()
286 | 
287 | 
288 | if __name__ == "__main__":
289 |     main()
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/settings.yml:
--------------------------------------------------------------------------------
 1 | ignore_dirs:
 2 |   - ".git"
 3 |   - "__pycache__"
 4 |   - ".venv"
 5 |   - "node_modules"
 6 |   - ".vscode"
 7 |   - ".idea"
 8 |   - "build"
 9 |   - "dist"
10 |   - "*.egg_info"
11 |   - ".mypy_cache"
12 | ignore_files:
13 |   - ".DS_Store"
14 |   - ".env"
15 |   - "thumbs.db"
16 | ignore_extensions:
17 |   images:
18 |     - '.png'
19 |     - '.jpg'
20 |     - '.jpeg'
21 |     - '.gif'
22 |     - '.bmp'
23 |     - '.tiff'
24 |     - '.webp'
25 |     - '.svg'
26 |     - '.ico'
27 |   videos:
28 |     - '.mp4'
29 |     - '.mov'
30 |     - '.avi'
31 |     - '.wmv'
32 |     - '.mp3'
33 |     - '.wav'
34 |     - '.ogg'
35 |   compressed:
36 |     - '.zip'
37 |     - '.gz'
38 |     - '.tar'
39 |     - '.rar'
40 |     - '.7z'
41 |   binaries:
42 |     - '.pyc'
43 |     - '.pyo'
44 |     - '.exe'
45 |     - '.dll'
46 |     - '.so'
47 |     - '.o'
48 |     - '.a'
49 |     - '.lib'
50 |   documents:
51 |     - '.pdf'
52 |     - '.doc'
53 |     - '.docx'
54 |     - '.xls'
55 |     - '.xlsx'
56 |     - '.ppt'
57 |     - '.pptx'
58 |   others:
59 |     - '.lock'
60 |     - '.log'
61 |     - '.sqlite'
62 |     - '.db'
63 | 
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/temp_lister_test/File_B.py:
--------------------------------------------------------------------------------
 [空ファイル]
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/temp_lister_test/file_z.txt:
--------------------------------------------------------------------------------
 [空ファイル]
--------------------------------------------------------------------------------


/pyproject.toml:
--------------------------------------------------------------------------------
 1 | [project]
 2 | name = "repository-reader"
 3 | version = "0.1.0"
 4 | description = ""
 5 | authors = [
 6 |     {name = "Your Name",email = "you@example.com"}
 7 | ]
 8 | readme = "README.md"
 9 | requires-python = ">=3.11"
10 | dependencies = [
11 |     "pyyaml (>=6.0.2,<7.0.0)",
12 |     "pydantic (>=2.11.3,<3.0.0)"
13 | ]
14 | 
15 | [tool.poetry]
16 | package-mode = false
17 | 
18 | 
19 | [build-system]
20 | requires = ["poetry-core>=2.0.0,<3.0.0"]
21 | build-backend = "poetry.core.masonry.api"
--------------------------------------------------------------------------------


/README.md:
--------------------------------------------------------------------------------
1 | ## repository reader
--------------------------------------------------------------------------------


/Taskfile.yaml:
--------------------------------------------------------------------------------
 1 | version: '3'
 2 | 
 3 | dotenv: ['.env']
 4 | 
 5 | tasks:
 6 |   build:
 7 |     desc: Dockerイメージのビルド
 8 |     cmds:
 9 |       - docker compose -f ./context/cpu/docker-compose.yaml build
10 | 
11 |   up:
12 |     desc: コンテナを起動
13 |     cmds:
14 |       - docker compose -f ./context/cpu/docker-compose.yaml up -d
15 | 
16 |   down:
17 |     desc: コンテナの停止と削除
18 |     cmds:
19 |       - docker compose -f ./context/cpu/docker-compose.yaml down
20 | 
21 |   write_uid_onto_env:
22 |     desc: ホストマシンのUIDとUSERNAMEを.envに書き込む
23 |     cmds:
24 |       - |
25 |         TEMP_FILE=$(mktemp)
26 |         grep -v "^USER_UID=" .env | grep -v "^USERNAME=" > $$TEMP_FILE
27 |         echo "USER_UID=$(id -u $(whoami))" >> $$TEMP_FILE
28 |         echo "USERNAME=$USER" >> $$TEMP_FILE
29 |         mv $$TEMP_FILE .env
30 | 
31 |   shell:
32 |     desc: UID書き込み -> build -> up -> コンテナに入る
33 |     cmds:
34 |       - task: write_uid_onto_env
35 |       - task: build
36 |       - task: up
37 |       - docker exec -it "{{.container_name}}" /bin/bash
38 |     vars:
39 |       container_name:
40 |         sh: 'echo ${CONTAINER_NAME}'
--------------------------------------------------------------------------------
