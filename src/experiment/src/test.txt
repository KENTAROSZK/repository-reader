experiment
├── src
│   ├── entrypoint.py
│   └── test.txt
└── pyproject.toml



/pyproject.toml:
--------------------------------------------------------------------------------
 1 | [project]
 2 | name = "repository-reader"
 3 | version = "0.1.0"
 4 | description = "read and extract directory structure and source code."
 5 | authors = [
 6 |     {name = "None"}
 7 | ]
 8 | readme = "README.md"
 9 | requires-python = ">=3.11"
10 | dependencies = [
11 | ]
12 | 
13 | 
14 | [build-system]
15 | requires = ["poetry-core>=2.0.0,<3.0.0"]
16 | build-backend = "poetry.core.masonry.api"
--------------------------------------------------------------------------------

/src/entrypoint.py:
--------------------------------------------------------------------------------
  1 | import os
  2 | from pathlib import Path
  3 | import argparse
  4 | 
  5 | # 無視するディレクトリ名、ファイル名、拡張子のセット
  6 | # プロジェクトに合わせて適宜変更してください
  7 | IGNORE_DIRS = {
  8 |     '.git',
  9 |     '__pycache__',
 10 |     '.venv',            # Python仮想環境
 11 |     'node_modules',     # Node.js パッケージ
 12 |     '.vscode',          # Visual Studio Code 設定
 13 |     '.idea',            # JetBrains IDE 設定
 14 |     'build',            # ビルド成果物
 15 |     'dist',             # 配布パッケージ
 16 |     '*.egg-info',       # Python パッケージ情報
 17 | }
 18 | IGNORE_FILES = {
 19 |     '.DS_Store',        # macOS システムファイル
 20 |     'thumbs.db',        # Windows システムファイル
 21 |     '.env',             # 環境変数ファイル (内容を表示したくない場合)
 22 | }
 23 | IGNORE_EXTENSIONS = {
 24 |     # 画像ファイル
 25 |     '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.webp', '.svg', '.ico',
 26 |     # 動画/音声ファイル
 27 |     '.mp4', '.mov', '.avi', '.wmv', '.mp3', '.wav', '.ogg',
 28 |     # 圧縮ファイル
 29 |     '.zip', '.gz', '.tar', '.rar', '.7z',
 30 |     # バイナリ/実行ファイル
 31 |     '.pyc', '.pyo', '.exe', '.dll', '.so', '.o', '.a', '.lib',
 32 |     # ドキュメント (内容表示が難しい場合)
 33 |     '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
 34 |     # その他
 35 |     '.lock', '.log', '.sqlite', '.db',
 36 | }
 37 | 
 38 | def should_ignore(path: Path) -> bool:
 39 |     """指定されたパスが無視対象かどうかを判定する"""
 40 |     # ディレクトリ名で無視
 41 |     if any(part in IGNORE_DIRS for part in path.parts):
 42 |         return True
 43 |     # ファイル名で無視
 44 |     if path.name in IGNORE_FILES:
 45 |         return True
 46 |     # 拡張子で無視
 47 |     if path.suffix.lower() in IGNORE_EXTENSIONS:
 48 |         return True
 49 |     return False
 50 | 
 51 | def generate_tree(start_path: Path, prefix: str = '', is_last: bool = True) -> str:
 52 |     """ディレクトリ構造をtree形式で生成する再帰関数"""
 53 |     structure = ""
 54 |     # 無視対象のディレクトリ/ファイルは処理しない
 55 |     if should_ignore(start_path):
 56 |         return ""
 57 | 
 58 |     connector = '└── ' if is_last else '├── '
 59 |     structure += f"{prefix}{connector}{start_path.name}\n"
 60 | 
 61 |     if start_path.is_dir():
 62 |         new_prefix = prefix + ('    ' if is_last else '│   ')
 63 |         # ディレクトリ内のアイテムを取得し、無視対象を除外してソート
 64 |         items = sorted(
 65 |             [item for item in start_path.iterdir() if not should_ignore(item)],
 66 |             key=lambda x: (x.is_file(), x.name.lower()) # ディレクトリを先に、次にファイル名でソート
 67 |         )
 68 |         for i, item in enumerate(items):
 69 |             is_last_item = (i == len(items) - 1)
 70 |             structure += generate_tree(item, new_prefix, is_last_item)
 71 | 
 72 |     return structure
 73 | 
 74 | def get_file_contents(root_path: Path) -> str:
 75 |     """指定されたディレクトリ以下の全ファイルのパスと内容を行番号付きで取得する"""
 76 |     contents = ""
 77 |     separator = "-" * 80 + "\n"
 78 |     processed_files_count = 0
 79 | 
 80 |     # rglob で再帰的にファイルを取得し、パスでソート
 81 |     all_paths = sorted([p for p in root_path.rglob('*')])
 82 | 
 83 |     for item in all_paths:
 84 |         # 無視対象をスキップ
 85 |         if should_ignore(item):
 86 |             continue
 87 | 
 88 |         if item.is_file():
 89 |             processed_files_count += 1
 90 |             # ルートパスからの相対パスを取得し、先頭に / を追加
 91 |             try:
 92 |                 relative_path = item.relative_to(root_path)
 93 |                 contents += f"\n/{relative_path}:\n"
 94 |             except ValueError:
 95 |                 # root_path自身がファイルの場合など
 96 |                 contents += f"\n/{item.name}:\n"
 97 | 
 98 |             contents += separator
 99 |             try:
100 |                 # さまざまなエンコーディングに対応し、エラーは無視
101 |                 with open(item, 'r', encoding='utf-8', errors='ignore') as f:
102 |                     lines = f.readlines()
103 |                     if not lines:
104 |                         contents += " [空ファイル]\n"
105 |                     else:
106 |                         # 行番号の桁数を計算
107 |                         max_digits = len(str(len(lines)))
108 |                         for i, line in enumerate(lines):
109 |                             # 行番号を右寄せでフォーマット
110 |                             line_num_str = str(i + 1).rjust(max_digits)
111 |                             # 末尾の改行は維持しつつ、余分な空白は削除
112 |                             contents += f"{line_num_str} | {line.rstrip()}\n"
113 |             except Exception as e:
114 |                 contents += f" [エラー] ファイル読み込み中にエラーが発生しました: {e}\n"
115 |             contents += separator
116 | 
117 |     if processed_files_count == 0:
118 |         contents += "\n[指定されたディレクトリ内に処理対象ファイルが見つかりませんでした]\n"
119 | 
120 |     return contents
121 | 
122 | def generate_directory_listing(directory_path: str, output_file: str) -> None:
123 |     """ディレクトリ構造とファイル内容を指定ファイルに出力する"""
124 |     start_path = Path(directory_path).resolve() # 絶対パスに変換
125 |     if not start_path.is_dir():
126 |         print(f"エラー: '{directory_path}' は有効なディレクトリではありません。")
127 |         return
128 | 
129 |     print(f"処理を開始します: {start_path}")
130 |     print(f"出力ファイル: {output_file}")
131 | 
132 |     # ディレクトリ構造の取得 (tree形式)
133 |     print("ディレクトリ構造を生成中...")
134 |     # ルートディレクトリ自体も表示するために少し調整
135 |     structure = f"{start_path.name}\n"
136 |     items = sorted(
137 |         [item for item in start_path.iterdir() if not should_ignore(item)],
138 |          key=lambda x: (x.is_file(), x.name.lower())
139 |     )
140 |     for i, item in enumerate(items):
141 |         is_last_item = (i == len(items) - 1)
142 |         structure += generate_tree(item, '', is_last_item)
143 |     print("ディレクトリ構造の生成完了。")
144 | 
145 |     # ファイル内容の取得
146 |     print("ファイル内容を取得中...")
147 |     file_contents_data = get_file_contents(start_path)
148 |     print("ファイル内容の取得完了。")
149 | 
150 |     # ファイルへの書き込み
151 |     print("ファイルに書き込み中...")
152 |     try:
153 |         # 出力ファイルのディレクトリが存在しない場合は作成
154 |         output_path = Path(output_file)
155 |         output_path.parent.mkdir(parents=True, exist_ok=True)
156 | 
157 |         with open(output_path, 'w', encoding='utf-8') as f:
158 |             f.write(structure)
159 |             f.write("\n\n") # treeと内容の間に空行を入れる
160 |             f.write(file_contents_data)
161 |         print(f"ディレクトリリストが '{output_path.resolve()}' に出力されました。")
162 |     except IOError as e:
163 |         print(f"エラー: ファイル '{output_file}' に書き込めませんでした: {e}")
164 |     except Exception as e:
165 |         print(f"予期せぬエラーが発生しました: {e}")
166 | 
167 | # --- コマンドライン引数の処理とメイン実行部分 ---
168 | if __name__ == "__main__":
169 |     parser = argparse.ArgumentParser(description="指定されたディレクトリの構造とファイル内容をリスト化してテキストファイルに出力します。")
170 |     parser.add_argument("directory", help="リスト化するディレクトリのパス")
171 |     parser.add_argument("output", help="出力するテキストファイル名")
172 | 
173 |     args = parser.parse_args()
174 | 
175 |     generate_directory_listing(args.directory, args.output)
--------------------------------------------------------------------------------

/src/test.txt:
--------------------------------------------------------------------------------
  1 | src
  2 | └── entrypoint.py
  3 | 
  4 | 
  5 | 
  6 | /entrypoint.py:
  7 | --------------------------------------------------------------------------------
  8 |   1 | import os
  9 |   2 | from pathlib import Path
 10 |   3 | import argparse
 11 |   4 |
 12 |   5 | # 無視するディレクトリ名、ファイル名、拡張子のセット
 13 |   6 | # プロジェクトに合わせて適宜変更してください
 14 |   7 | IGNORE_DIRS = {
 15 |   8 |     '.git',
 16 |   9 |     '__pycache__',
 17 |  10 |     '.venv',            # Python仮想環境
 18 |  11 |     'node_modules',     # Node.js パッケージ
 19 |  12 |     '.vscode',          # Visual Studio Code 設定
 20 |  13 |     '.idea',            # JetBrains IDE 設定
 21 |  14 |     'build',            # ビルド成果物
 22 |  15 |     'dist',             # 配布パッケージ
 23 |  16 |     '*.egg-info',       # Python パッケージ情報
 24 |  17 | }
 25 |  18 | IGNORE_FILES = {
 26 |  19 |     '.DS_Store',        # macOS システムファイル
 27 |  20 |     'thumbs.db',        # Windows システムファイル
 28 |  21 |     '.env',             # 環境変数ファイル (内容を表示したくない場合)
 29 |  22 | }
 30 |  23 | IGNORE_EXTENSIONS = {
 31 |  24 |     # 画像ファイル
 32 |  25 |     '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.webp', '.svg', '.ico',
 33 |  26 |     # 動画/音声ファイル
 34 |  27 |     '.mp4', '.mov', '.avi', '.wmv', '.mp3', '.wav', '.ogg',
 35 |  28 |     # 圧縮ファイル
 36 |  29 |     '.zip', '.gz', '.tar', '.rar', '.7z',
 37 |  30 |     # バイナリ/実行ファイル
 38 |  31 |     '.pyc', '.pyo', '.exe', '.dll', '.so', '.o', '.a', '.lib',
 39 |  32 |     # ドキュメント (内容表示が難しい場合)
 40 |  33 |     '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
 41 |  34 |     # その他
 42 |  35 |     '.lock', '.log', '.sqlite', '.db',
 43 |  36 | }
 44 |  37 |
 45 |  38 | def should_ignore(path: Path) -> bool:
 46 |  39 |     """指定されたパスが無視対象かどうかを判定する"""
 47 |  40 |     # ディレクトリ名で無視
 48 |  41 |     if any(part in IGNORE_DIRS for part in path.parts):
 49 |  42 |         return True
 50 |  43 |     # ファイル名で無視
 51 |  44 |     if path.name in IGNORE_FILES:
 52 |  45 |         return True
 53 |  46 |     # 拡張子で無視
 54 |  47 |     if path.suffix.lower() in IGNORE_EXTENSIONS:
 55 |  48 |         return True
 56 |  49 |     return False
 57 |  50 |
 58 |  51 | def generate_tree(start_path: Path, prefix: str = '', is_last: bool = True) -> str:
 59 |  52 |     """ディレクトリ構造をtree形式で生成する再帰関数"""
 60 |  53 |     structure = ""
 61 |  54 |     # 無視対象のディレクトリ/ファイルは処理しない
 62 |  55 |     if should_ignore(start_path):
 63 |  56 |         return ""
 64 |  57 |
 65 |  58 |     connector = '└── ' if is_last else '├── '
 66 |  59 |     structure += f"{prefix}{connector}{start_path.name}\n"
 67 |  60 |
 68 |  61 |     if start_path.is_dir():
 69 |  62 |         new_prefix = prefix + ('    ' if is_last else '│   ')
 70 |  63 |         # ディレクトリ内のアイテムを取得し、無視対象を除外してソート
 71 |  64 |         items = sorted(
 72 |  65 |             [item for item in start_path.iterdir() if not should_ignore(item)],
 73 |  66 |             key=lambda x: (x.is_file(), x.name.lower()) # ディレクトリを先に、次にファイル名でソート
 74 |  67 |         )
 75 |  68 |         for i, item in enumerate(items):
 76 |  69 |             is_last_item = (i == len(items) - 1)
 77 |  70 |             structure += generate_tree(item, new_prefix, is_last_item)
 78 |  71 |
 79 |  72 |     return structure
 80 |  73 |
 81 |  74 | def get_file_contents(root_path: Path) -> str:
 82 |  75 |     """指定されたディレクトリ以下の全ファイルのパスと内容を行番号付きで取得する"""
 83 |  76 |     contents = ""
 84 |  77 |     separator = "-" * 80 + "\n"
 85 |  78 |     processed_files_count = 0
 86 |  79 |
 87 |  80 |     # rglob で再帰的にファイルを取得し、パスでソート
 88 |  81 |     all_paths = sorted([p for p in root_path.rglob('*')])
 89 |  82 |
 90 |  83 |     for item in all_paths:
 91 |  84 |         # 無視対象をスキップ
 92 |  85 |         if should_ignore(item):
 93 |  86 |             continue
 94 |  87 |
 95 |  88 |         if item.is_file():
 96 |  89 |             processed_files_count += 1
 97 |  90 |             # ルートパスからの相対パスを取得し、先頭に / を追加
 98 |  91 |             try:
 99 |  92 |                 relative_path = item.relative_to(root_path)
100 |  93 |                 contents += f"\n/{relative_path}:\n"
101 |  94 |             except ValueError:
102 |  95 |                 # root_path自身がファイルの場合など
103 |  96 |                 contents += f"\n/{item.name}:\n"
104 |  97 |
105 |  98 |             contents += separator
106 |  99 |             try:
107 | 100 |                 # さまざまなエンコーディングに対応し、エラーは無視
108 | 101 |                 with open(item, 'r', encoding='utf-8', errors='ignore') as f:
109 | 102 |                     lines = f.readlines()
110 | 103 |                     if not lines:
111 | 104 |                         contents += " [空ファイル]\n"
112 | 105 |                     else:
113 | 106 |                         # 行番号の桁数を計算
114 | 107 |                         max_digits = len(str(len(lines)))
115 | 108 |                         for i, line in enumerate(lines):
116 | 109 |                             # 行番号を右寄せでフォーマット
117 | 110 |                             line_num_str = str(i + 1).rjust(max_digits)
118 | 111 |                             # 末尾の改行は維持しつつ、余分な空白は削除
119 | 112 |                             contents += f"{line_num_str} | {line.rstrip()}\n"
120 | 113 |             except Exception as e:
121 | 114 |                 contents += f" [エラー] ファイル読み込み中にエラーが発生しました: {e}\n"
122 | 115 |             contents += separator
123 | 116 |
124 | 117 |     if processed_files_count == 0:
125 | 118 |         contents += "\n[指定されたディレクトリ内に処理対象ファイルが見つかりませんでした]\n"
126 | 119 |
127 | 120 |     return contents
128 | 121 |
129 | 122 | def generate_directory_listing(directory_path: str, output_file: str) -> None:
130 | 123 |     """ディレクトリ構造とファイル内容を指定ファイルに出力する"""
131 | 124 |     start_path = Path(directory_path).resolve() # 絶対パスに変換
132 | 125 |     if not start_path.is_dir():
133 | 126 |         print(f"エラー: '{directory_path}' は有効なディレクトリではありません。")
134 | 127 |         return
135 | 128 |
136 | 129 |     print(f"処理を開始します: {start_path}")
137 | 130 |     print(f"出力ファイル: {output_file}")
138 | 131 |
139 | 132 |     # ディレクトリ構造の取得 (tree形式)
140 | 133 |     print("ディレクトリ構造を生成中...")
141 | 134 |     # ルートディレクトリ自体も表示するために少し調整
142 | 135 |     structure = f"{start_path.name}\n"
143 | 136 |     items = sorted(
144 | 137 |         [item for item in start_path.iterdir() if not should_ignore(item)],
145 | 138 |          key=lambda x: (x.is_file(), x.name.lower())
146 | 139 |     )
147 | 140 |     for i, item in enumerate(items):
148 | 141 |         is_last_item = (i == len(items) - 1)
149 | 142 |         structure += generate_tree(item, '', is_last_item)
150 | 143 |     print("ディレクトリ構造の生成完了。")
151 | 144 |
152 | 145 |     # ファイル内容の取得
153 | 146 |     print("ファイル内容を取得中...")
154 | 147 |     file_contents_data = get_file_contents(start_path)
155 | 148 |     print("ファイル内容の取得完了。")
156 | 149 |
157 | 150 |     # ファイルへの書き込み
158 | 151 |     print("ファイルに書き込み中...")
159 | 152 |     try:
160 | 153 |         # 出力ファイルのディレクトリが存在しない場合は作成
161 | 154 |         output_path = Path(output_file)
162 | 155 |         output_path.parent.mkdir(parents=True, exist_ok=True)
163 | 156 |
164 | 157 |         with open(output_path, 'w', encoding='utf-8') as f:
165 | 158 |             f.write(structure)
166 | 159 |             f.write("\n\n") # treeと内容の間に空行を入れる
167 | 160 |             f.write(file_contents_data)
168 | 161 |         print(f"ディレクトリリストが '{output_path.resolve()}' に出力されました。")
169 | 162 |     except IOError as e:
170 | 163 |         print(f"エラー: ファイル '{output_file}' に書き込めませんでした: {e}")
171 | 164 |     except Exception as e:
172 | 165 |         print(f"予期せぬエラーが発生しました: {e}")
173 | 166 |
174 | 167 | # --- コマンドライン引数の処理とメイン実行部分 ---
175 | 168 | if __name__ == "__main__":
176 | 169 |     parser = argparse.ArgumentParser(description="指定されたディレクトリの構造とファイル内容をリスト化してテキストファイルに出力します。")
177 | 170 |     parser.add_argument("directory", help="リスト化するディレクトリのパス")
178 | 171 |     parser.add_argument("output", help="出力するテキストファイル名")
179 | 172 |
180 | 173 |     args = parser.parse_args()
181 | 174 |
182 | 175 |     generate_directory_listing(args.directory, args.output)
183 | --------------------------------------------------------------------------------
--------------------------------------------------------------------------------
