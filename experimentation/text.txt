--- ディレクトリ構造 ---
repository-reader
├── context
│   ├── cpu
│   │   └── docker-compose.yaml
│   └── Dockerfile
├── experimentation
│   ├── llm-outputs.md
│   └── rag.py
├── project_module
│   └── src
│       └── project_module
│           ├── directory_lister
│           │   ├── temp_lister_test
│           │   │   ├── dir_a
│           │   │   ├── dir_c
│           │   │   ├── File_B.py
│           │   │   └── file_z.txt
│           │   ├── __init__.py
│           │   ├── directory_lister.py
│           │   ├── ignore_config.py
│           │   └── ignore_settings.yml
│           └── __init__.py
├── .gitignore
├── pyproject.toml
├── README.md
└── Taskfile.yaml


--- ファイル内容 ---


/.gitignore:
--------------------------------------------------------------------------------
1 | # 環境変数
2 | .env*
3 | env/
4 | 
5 | .local*
--------------------------------------------------------------------------------


/context/cpu/docker-compose.yaml:
--------------------------------------------------------------------------------
 1 | services:
 2 |   python-dev: # サービス名 (任意)
 3 |     build:
 4 |       context: ../../context/
 5 |       dockerfile: Dockerfile
 6 |       args:
 7 |         POETRY_VERSION: ${POETRY_VERSION}
 8 |         POETRY_HOME: ${POETRY_HOME}
 9 |         USER_UID: ${USER_UID}
10 |         USERNAME: ${USERNAME}
11 |         PROJECT_NAME: ${PROJECT_NAME}
12 |     container_name: ${CONTAINER_NAME}
13 |     volumes:
14 |       - type: bind
15 |         source: ../../
16 |         target: /home/${USERNAME}/${PROJECT_NAME}
17 |     working_dir: /home/${USERNAME}/${PROJECT_NAME}
18 |     tty: true
19 |     restart: always # コンテナが停止した場合に常に再起動する
--------------------------------------------------------------------------------


/context/Dockerfile:
--------------------------------------------------------------------------------
 1 | FROM python:3.11-slim
 2 | 
 3 | # Build-time arguments
 4 | ARG POETRY_VERSION
 5 | ARG POETRY_HOME
 6 | ARG USER_UID
 7 | ARG USERNAME
 8 | ARG PROJECT_NAME
 9 | 
10 | # 必要なパッケージをインストール（curl等）
11 | RUN apt-get update && apt-get install -y --no-install-recommends \
12 |     curl \
13 |     && apt-get clean \
14 |     && rm -rf /var/lib/apt/lists/*
15 | 
16 | # Poetryのインストール
17 | RUN echo ${POETRY_HOME}
18 | SHELL ["/bin/bash", "-o", "pipefail", "-c"]
19 | RUN curl -sSL https://install.python-poetry.org/ | python3 - --version ${POETRY_VERSION} && \
20 |     ln -s ${POETRY_HOME}/bin/poetry /usr/local/bin/poetry
21 | 
22 | # Node.jsとnpmのインストール
23 | RUN curl -fsSL https://deb.nodesource.com/setup_18.x | bash - && \
24 | apt-get install -y --no-install-recommends nodejs && \
25 | apt-get clean && \
26 | rm -rf /var/lib/apt/lists/*
27 | 
28 | 
29 | # ==========================================
30 | # Create user in the container to avoid permission matter
31 | # incompatible between host and container user
32 | # ==========================================
33 | RUN useradd --uid ${USER_UID} -m ${USERNAME}
34 | 
35 | USER $USERNAME
36 | ENV PATH="/usr/local/bin:$PATH"
37 | 
38 | 
39 | WORKDIR /home/${USERNAME}/${PROJECT_NAME}
--------------------------------------------------------------------------------


/experimentation/llm-outputs.md:
--------------------------------------------------------------------------------
  1 | ```markdown
  2 | # Repository Reader
  3 | 
  4 | ## プロジェクトの概要
  5 | 
  6 | このリポジトリは、指定されたディレクトリの構造とファイルの内容をテキスト形式で出力するツールです。
  7 | 大規模なプロジェクトの構造を把握したり、ドキュメント生成の補助として利用することを想定しています。
  8 | LangchainとGoogle Gemini APIを使用し、リポジトリの情報を基に、READMEなどのドキュメントを自動生成する機能も備えています。
  9 | 
 10 | ## 開発環境の構築手順
 11 | 
 12 | 以下の手順で開発環境を構築します。
 13 | 
 14 | 1.  **必要なツールのインストール:**
 15 | 
 16 |     *   [Docker](https://www.docker.com/)
 17 |     *   [Docker Compose](https://docs.docker.com/compose/)
 18 |     *   [Taskfile](https://taskfile.dev/)
 19 | 
 20 | 2.  **リポジトリのクローン:**
 21 | 
 22 |     ```bash
 23 |     git clone <リポジトリのURL>
 24 |     cd repository-reader
 25 |     ```
 26 | 
 27 | 3.  **.envファイルの作成:**
 28 | 
 29 |     リポジトリのルートディレクトリに`.env`ファイルを作成し、必要な環境変数を設定します。
 30 |     セキュリティ上の理由から、このファイルはリポジトリには含まれていません。
 31 |     必要な環境変数は以下の通りです。
 32 | 
 33 |     *   `POETRY_VERSION`: Poetryのバージョン (例: `1.7.1`)
 34 |     *   `POETRY_HOME`: Poetryのインストール先 (例: `/opt/poetry`)
 35 |     *   `USER_UID`: ユーザーのUID (例: `1000`)
 36 |     *   `USERNAME`: ユーザー名 (例: `dev`)
 37 |     *   `PROJECT_NAME`: プロジェクト名 (例: `repository-reader`)
 38 |     *   `CONTAINER_NAME`: コンテナ名 (例: `repository-reader-dev`)
 39 | 
 40 |     ```bash
 41 |     touch .env
 42 |     ```
 43 | 
 44 | 4.  **UIDとUSERNAMEを.envに書き込み:**
 45 |     ```bash
 46 |     task write_uid_onto_env
 47 |     ```
 48 | 
 49 | 5.  **Dockerコンテナの起動:**
 50 | 
 51 |     Taskfileを使用することで、Dockerイメージのビルドからコンテナの起動までを簡単に行うことができます。
 52 | 
 53 |     ```bash
 54 |     task shell
 55 |     ```
 56 | 
 57 |     このコマンドは、以下の処理を順番に実行します。
 58 | 
 59 |     1.  `write_uid_onto_env`: ホストマシンのUIDとUSERNAMEを`.env`ファイルに書き込みます。
 60 |     2.  `build`: `docker-compose.yaml`ファイルを使用してDockerイメージをビルドします。
 61 |     3.  `up`: Dockerコンテナを起動します。
 62 |     4.  `docker exec`: 起動したコンテナにログインします。
 63 | 
 64 | ## フォルダ構成
 65 | 
 66 | ```
 67 | repository-reader/
 68 | ├── context/                      # Dockerコンテナの定義ファイル
 69 | │   ├── cpu/
 70 | │   │   └── docker-compose.yaml  # Docker Composeファイル（CPU環境用）
 71 | │   └── Dockerfile              # DockerイメージのDockerfile
 72 | ├── experimentation/            # 実験的なコードやスクリプト
 73 | │   ├── rag.py                  # RAG(Retrieval Augmented Generation)の実験用スクリプト
 74 | │   └── text.txt                # RAGの出力先
 75 | ├── project_module/             # プロジェクトのメインモジュール
 76 | │   └── src/
 77 | │       └── project_module/
 78 | │           ├── directory_lister/    # ディレクトリ構造をリスト化するモジュール
 79 | │           │   ├── temp_lister_test/  # directory_listerのテスト用ファイル
 80 | │           │   │   ├── dir_a/
 81 | │           │   │   ├── dir_c/
 82 | │           │   │   ├── File_B.py
 83 | │           │   │   └── file_z.txt
 84 | │           │   ├── __init__.py
 85 | │           │   ├── directory_lister.py # ディレクトリ構造リスト化のメイン処理
 86 | │           │   ├── ignore_config.py  # 無視するファイルやディレクトリの設定
 87 | │           │   └── ignore_settings.yml # 無視設定ファイル
 88 | │           └── __init__.py
 89 | ├── .gitignore                  # Gitで管理しないファイルの設定
 90 | ├── pyproject.toml              # Poetryの設定ファイル
 91 | ├── README.md                   # プロジェクトのREADME
 92 | └── Taskfile.yaml               # Taskfileの設定ファイル
 93 | 
 94 | ```
 95 | 
 96 | *   **context:** Dockerコンテナの構築に必要なファイルが含まれています。`Dockerfile`はPythonの開発環境を構築し、`docker-compose.yaml`はコンテナの起動設定を定義します。
 97 | *   **experimentation:** RAGの実験に使用するスクリプトやテキストファイルが含まれています。
 98 | *   **project\_module:** プロジェクトのメインとなるモジュールが含まれています。
 99 |     *   **directory\_lister:** ディレクトリ構造をリスト化する機能を提供するモジュールです。
100 |         *   `directory_lister.py`: ディレクトリ構造を走査し、ファイルとディレクトリの情報を収集する主要なスクリプトです。
101 |         *   `ignore\_config.py`: 無視するファイルやディレクトリのパターンを定義するための設定を管理します。
102 |         *   `ignore\_settings.yml`: 無視するファイルやディレクトリの具体的な設定を記述します。
103 | *   **.gitignore:** Gitで管理しないファイルやディレクトリを指定します。
104 | *   **pyproject.toml:** Poetryのプロジェクト設定ファイルです。依存関係やプロジェクトのメタ情報が記述されています。
105 | *   **README.md:** プロジェクトの概要や使い方を説明するファイルです。
106 | *   **Taskfile.yaml:** Taskfileの設定ファイルです。Dockerコンテナのビルドや起動などのタスクを定義します。
107 | 
108 | ## どこでどんな処理がなされているか
109 | 
110 | *   **`project_module/src/project_module/directory_lister/directory_lister.py`:**
111 |     *   `DirectoryLister`クラスが定義されており、以下の処理を行います。
112 |         *   指定されたディレクトリを走査し、ファイルとディレクトリの情報を収集します。
113 |         *   `ignore_settings.yml`に基づいて、無視するファイルやディレクトリをフィルタリングします。
114 |         *   ディレクトリ構造をtree形式で出力します。
115 |         *   ファイルの内容を行番号付きで出力します。
116 | *   **`experimentation/rag.py`:**
117 |     *   `DirectoryLister`を使用してリポジトリの構造とコードを取得します。
118 |     *   取得した情報をLangchainとGoogle Gemini APIに渡し、READMEを自動生成します。
119 | *   **`context/Dockerfile`:**
120 |     *   Python 3.11をベースにしたDockerイメージを構築します。
121 |     *   PoetryとNode.jsをインストールします。
122 |     *   開発用のユーザーを作成し、必要な環境変数を設定します。
123 | 
124 | ## 使い方
125 | 
126 | 1.  **開発環境の構築:** 上記の「開発環境の構築手順」に従って環境を構築します。
127 | 2.  **環境変数の設定:** `.env`ファイルに必要な環境変数を設定します。特に、Google Gemini APIを使用する場合は、APIキーを設定する必要があります。
128 | 3.  **スクリプトの実行:**
129 | 
130 |     *   リポジトリ全体の構造とコードをテキストファイルに出力するには、`project_module/src/project_module/directory_lister/directory_lister.py`を実行します。
131 | 
132 |         ```bash
133 |         # コンテナに入っている状態で実行
134 |         python project_module/src/project_module/directory_lister/directory_lister.py
135 |         ```
136 | 
137 |         出力ファイルは`text.txt`として保存されます。
138 | 
139 |     *   RAGを使用してREADMEを自動生成するには、`experimentation/rag.py`を実行します。
140 | 
141 |         ```bash
142 |         # コンテナに入っている状態で実行
143 |         python experimentation/rag.py
144 |         ```
145 | 
146 |         生成されたREADMEの内容は、コンソールに出力されるとともに、`llm-outputs.txt`ファイルに保存されます。
147 | 
148 | ## 処理フロー
149 | 
150 | ### DirectoryLister
151 | 
152 | ```mermaid
153 | graph LR
154 |     A[開始] --> B{設定ファイルの読み込み (ignore_settings.yml)};
155 |     B --> C{DirectoryListerのインスタンス化};
156 |     C --> D{ディレクトリ構造の生成};
157 |     D --> E{ファイル内容の生成};
158 |     E --> F{ファイルへ書き込み (text.txt)};
159 |     F --> G[終了];
160 |     style A fill:#f9f,stroke:#333,stroke-width:2px
161 |     style G fill:#f9f,stroke:#333,stroke-width:2px
162 | ```
163 | 
164 | ### RAG
165 | 
166 | ```mermaid
167 | graph LR
168 |     A[開始] --> B{設定ファイルの読み込み (ignore_settings.yml)};
169 |     B --> C{DirectoryListerのインスタンス化};
170 |     C --> D{ディレクトリ構造の生成};
171 |     D --> E{ファイル内容の生成};
172 |     E --> F{ファイルへ書き込み (text.txt)};
173 |     F --> G{テキストファイルの読み込み};
174 |     G --> H{Gemini APIへのプロンプト送信};
175 |     H --> I{README生成};
176 |     I --> J{READMEのファイルへ書き出し (llm-outputs.txt)};
177 |     J --> K[終了];
178 |     style A fill:#f9f,stroke:#333,stroke-width:2px
179 |     style K fill:#f9f,stroke:#333,stroke-width:2px
180 | ```
181 | 
182 | **フローの説明:**
183 | 
184 | 1.  **設定ファイルの読み込み:** `ignore_settings.yml`を読み込み、無視するファイルやディレクトリの設定を取得します。
185 | 2.  **DirectoryListerのインスタンス化:** 読み込んだ設定を基に、`DirectoryLister`クラスのインスタンスを作成します。
186 | 3.  **ディレクトリ構造の生成:** `DirectoryLister`を使用して、指定されたディレクトリの構造をtree形式で生成します。
187 | 4.  **ファイル内容の生成:** `DirectoryLister`を使用して、指定されたディレクトリ内の各ファイルの内容を行番号付きで生成します。
188 | 5.  **ファイルへ書き込み:** 生成されたディレクトリ構造とファイルの内容を`text.txt`ファイルに書き込みます。
189 | 6.  **テキストファイルの読み込み:**  `text.txt`ファイルの内容を読み込みます。
190 | 7.  **Gemini APIへのプロンプト送信:** 読み込んだファイルの内容と、README生成を指示するプロンプトをGemini APIへ送信します。
191 | 8.  **README生成:** Gemini APIからの応答に基づき、READMEの内容を生成します。
192 | 9.  **READMEのファイルへ書き出し:** 生成されたREADMEの内容を`llm-outputs.txt`ファイルに書き出します。
193 | 10. **終了:** 処理を終了します。
194 | ```
--------------------------------------------------------------------------------


/experimentation/rag.py:
--------------------------------------------------------------------------------
 1 | import sys
 2 | import os
 3 | from dotenv import load_dotenv
 4 | from pathlib import Path
 5 | from langchain_google_genai import ChatGoogleGenerativeAI
 6 | 
 7 | # 自作モジュールをインポート
 8 | sys.path.append(os.path.abspath("../project_module/src/project_module"))
 9 | from directory_lister.directory_lister import DirectoryLister
10 | from directory_lister.ignore_config import get_config, IgnoreConfig
11 | 
12 | 
13 | # 検索を開始するディレクトリのパスを指定
14 | ROOT_DIR = Path(__file__).resolve().parents[1] # 2つ上のディレクトリを取得する
15 | # テキストファイルの出力先のパスを指定
16 | DIR_AND_CODES_FILE = Path(__file__).resolve().parent / 'text.txt'
17 | # 設定ファイルのパスを指定
18 | SETTING_YML_DIR = Path(__file__).resolve().parent.parent/ "project_module/src/project_module/directory_lister" / 'ignore_settings.yml'
19 | 
20 | # 環境変数を取得
21 | DOT_ENV_PATH = Path(__file__).resolve().parent.parent / '.env'
22 | load_dotenv(DOT_ENV_PATH)
23 | 
24 | 
25 | def main() -> None:
26 | 
27 |     # インスタンス化
28 |     lister = DirectoryLister(
29 |         directory_path=Path(ROOT_DIR),
30 |         output_file=Path(DIR_AND_CODES_FILE),
31 |         config=get_config(Path(SETTING_YML_DIR))
32 |     )
33 | 
34 |     # ディレクトリリスト化を実行
35 |     lister.run()
36 | 
37 |     with open(DIR_AND_CODES_FILE, 'r', encoding='utf-8') as f:
38 |         dir_and_codes: str = f.read()
39 | 
40 |     question: str = """
41 | このリポジトリを公開するためのREADME.mdを作成してください。
42 | READMEの内容は、以下の内容を含めてください。
43 | - プロジェクトの概要
44 | - 開発環境の構築手順
45 | - フォルダの構成とそれぞれの簡単な説明
46 | - どこでどんな処理がなされているか
47 | - 使い方
48 | - 処理フローを示すmermaid記法の図
49 | """
50 |     prompt = f"""
51 | 以下の内容は、今開発しているリポジトリのコードのディレクトリとそのソースコードです。
52 | 環境変数などの設定ファイルは、セキュリティ上の理由でテキスト化していません。
53 | 質問に答えてください。
54 | 
55 | # 質問
56 | {question}
57 | 
58 | # ディレクトリとソースコード
59 | {dir_and_codes}
60 | """
61 | 
62 |     print("="*30)
63 |     llm = ChatGoogleGenerativeAI(
64 |         model="gemini-2.0-flash"
65 |     )
66 |     results = llm.invoke(prompt)
67 |     content = results.content
68 |     print(content)
69 | 
70 |     with open(Path("./llm-outputs.md"), 'w', encoding='utf-8') as f:
71 |         f.write(content)
72 | 
73 | 
74 | 
75 | 
76 | 
77 | if __name__ == "__main__":
78 |     main()
--------------------------------------------------------------------------------


/project_module/src/project_module/__init__.py:
--------------------------------------------------------------------------------
 [空ファイル]
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/__init__.py:
--------------------------------------------------------------------------------
 [空ファイル]
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/directory_lister.py:
--------------------------------------------------------------------------------
  1 | from pathlib import Path
  2 | from typing import List
  3 | from .ignore_config import get_config, IgnoreConfig
  4 | 
  5 | import os
  6 | import sys
  7 | 
  8 | 
  9 | class DirectoryLister:
 10 |     def __init__(
 11 |             self,
 12 |             directory_path: Path,
 13 |             output_file: Path,
 14 |             config: IgnoreConfig
 15 |     ):
 16 |         self.root_path = directory_path.resolve() # 絶対パスに変換
 17 |         self.output_file = output_file
 18 |         self.config = config
 19 | 
 20 |         if not self.root_path.is_dir():
 21 |             raise ValueError(f"{self.root_path} is not a directory.")
 22 | 
 23 |         self.ignore_dirs = getattr(self.config, "ignore_dirs")
 24 |         self.ignore_files = getattr(self.config, "ignore_files")
 25 |         self.ignore_extensions = getattr(self.config.ignore_extensions, "all_extensions")()
 26 |         self.ignore_files.append(str(output_file)) # 過去に出力したテキストを無視する必要がある
 27 | 
 28 | 
 29 |     def _should_ignore(self, path: Path) -> bool:
 30 |         """指定されたパスが無視対象かどうかを判定する"""
 31 |         if any(part in self.ignore_dirs for part in path.parts): return True # ディレクトリ名で無視
 32 |         if path.name in self.ignore_files: return True # ファイル名で無視
 33 |         if path.suffix.lower() in self.ignore_extensions: return True # 拡張子で無視
 34 | 
 35 |         return False
 36 | 
 37 | 
 38 |     def _get_sorted_items(self, directory: Path) -> List[Path]:
 39 |         """指定されたディレクトリ内のアイテムを無視対象を除外してソートする. 内部メソッド"""
 40 |         # TODO: パーミッションエラーやディレクトリを見つけられなかった時のエラーハンドリングを追加する
 41 | 
 42 |         # ディレクトリ内のアイテムを取得し、無視対象を除外してソート
 43 |         filtered_items = [item for item in directory.iterdir() if not self._should_ignore(item)]
 44 |         items = sorted(
 45 |             filtered_items,
 46 |             key=lambda x: (x.is_file(), x.name.lower()) # ディレクトリを先に、次にファイル名でソート
 47 |         )
 48 |         return items
 49 | 
 50 | 
 51 |     def _generate_tree_recursive(
 52 |             self,
 53 |             current_path: Path,
 54 |             prefix: str = "",
 55 |             is_last: bool=True
 56 |     ) -> str:
 57 |         """ディレクトリ構造をtree形式で再帰的に生成する（内部メソッド）"""
 58 |         structure = ""
 59 |         connector = '└── ' if is_last else '├── '
 60 | 
 61 |         try:
 62 |             structure += f"{prefix}{connector}{current_path.name}\n"
 63 | 
 64 |             # ディレクトリの場合は再起的に呼び出す
 65 |             if current_path.is_dir():
 66 |                 new_prefix = prefix + ('    ' if is_last else '│   ')
 67 |                 # サブアイテムを取得する
 68 |                 items = self._get_sorted_items(current_path)
 69 |                 item_count = len(items)
 70 | 
 71 |                 for i, item in enumerate(items):
 72 |                     is_last_item= (i == item_count - 1)
 73 |                     # 再帰的に呼び出す
 74 |                     structure += self._generate_tree_recursive(item, new_prefix, is_last_item)
 75 | 
 76 |         except OSError as e:
 77 |             structure += f"{prefix}{connector}[エラー: {e.strerror} ({current_path.name})]\n"
 78 |         except Exception as e:
 79 |             structure += f"{prefix}{connector}[予期せぬエラー: {e} ({current_path.name})]\n"
 80 | 
 81 |         return structure
 82 | 
 83 | 
 84 |     def generate_tree_structure(self)-> str:
 85 |         """ルートディレクトリから始まる全体のディレクt理構造の文字列を生成する"""
 86 |         structure = f"{self.root_path.name}\n"
 87 |         print(structure)
 88 | 
 89 |         # ルートディレクトリのアイテムを取得
 90 |         items = self._get_sorted_items(self.root_path)
 91 | 
 92 |         # 各アイテムに対して再起的に処理をする
 93 |         num_items = len(items)
 94 |         for i, item in enumerate(items):
 95 |             is_last_item = (i == num_items - 1)
 96 |             structure += self._generate_tree_recursive(item, "", is_last_item) # prefixは空文字列で初期化
 97 | 
 98 |         return structure
 99 | 
100 | 
101 |     def _format_file_content(self, file_path: Path) -> str:
102 |         """単一のファイルのパスと内容を読み込み、整形して文字列で返す。 内部メソッド"""
103 | 
104 |         content_str = "" # 結果の文字列
105 |         separator = "-" * 80 + "\n" # 区切り線の定義
106 | 
107 |         # 相対パスの取得
108 |         relative_path = file_path.relative_to(self.root_path) # 相対パスを取得
109 |         content_str += f"\n\n/{relative_path}:\n" # 相対パスを表示
110 | 
111 |         content_str += separator
112 | 
113 |         # ファイルの内容を読み込む
114 |         try:
115 |             with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
116 |                 lines = f.readlines() # ファイルの全行をリストとして読み込む
117 | 
118 |             if not lines: # 空ファイルの場合
119 |                 content_str += " [空ファイル]\n"
120 |             else:
121 |                 max_digits = len(str(len(lines))) # 行番号の桁数を計算。仮に20行であればmax_digitsは2になる。
122 |                 for i, line in enumerate(lines):
123 |                     line_num_str = str(i+1).rjust(max_digits) # 行番号を右寄せで整形
124 |                     content_str += f"{line_num_str} | {line.rstrip()}\n" # 行末の改行文字（rstrip()）を除去して、整形して追加
125 |         except PermissionError:
126 |             content_str += f" [エラー] ファイル '{file_path.name}' へのアクセス権がありません。\n"
127 |         except OSError as e:
128 |             content_str += f" [エラー] ファイル '{file_path.name}' 読み込み中にOSエラーが発生しました: {e.strerror}\n"
129 |         except Exception as e:
130 |             content_str += f" [エラー] ファイル '{file_path.name}' 読み込み中に予期せぬエラーが発生しました: {e}\n"
131 | 
132 |         content_str += separator # 最後に区切り線を追加
133 |         return content_str
134 | 
135 | 
136 |     def generate_file_contents(self)->str:
137 |         """全ファイルのパスと内容を行番号付きで取得する"""
138 |         contents=""
139 | 
140 |         files = [os.path.join(dirpath, f) for dirpath, _, filenames in os.walk(self.root_path) for f in filenames]
141 |         files = [item for item in files if not self._should_ignore(Path(item))] # 無視対象を除外
142 |         files = sorted(files, key=lambda x: (os.path.isfile(x), x.lower())) # ディレクトリを先に、次にファイル名でソート
143 |         files = [Path(item) for item in files] # Pathオブジェクトに変換
144 | 
145 |         for file in files:
146 |             contents += self._format_file_content(file)
147 | 
148 |         return contents
149 | 
150 | 
151 |     def write_to_file(self, tree_structure: str, file_contents: str) -> None:
152 |         """
153 |         生成したディレクトリ構造とファイル内容を指定されたファイルに書き込む。
154 | 
155 |         Args:
156 |             tree_structure (str): generate_tree_structureで生成された文字列。
157 |             file_contents (str): generate_file_contentsで生成された文字列。
158 |         """
159 |         print(f"ファイル '{self.output_file}' に書き込み中...")
160 |         try:
161 |             # --- 出力ファイルの親ディレクトリが存在しない場合に作成 ---
162 |             # self.output_path.parent は出力ファイルの親ディレクトリのPathオブジェクト
163 |             # parents=True: 中間ディレクトリもまとめて作成 (例: /a/b/c.txt で a, b がなくても作る)
164 |             # exist_ok=True: ディレクトリが既に存在していてもエラーにしない
165 |             self.output_file.parent.mkdir(parents=True, exist_ok=True)
166 | 
167 |             # --- ファイルへの書き込み ---
168 |             # 'w'モード: 書き込みモード。ファイルが存在すれば上書き、なければ新規作成。
169 |             # encoding='utf-8': UTF-8エンコーディングで書き込む。
170 |             with open(self.output_file, 'w', encoding='utf-8') as f:
171 |                 f.write("--- ディレクトリ構造 ---\n")
172 |                 f.write(tree_structure)
173 |                 f.write("\n\n--- ファイル内容 ---\n") # 構造と内容の間に区切りを入れる
174 |                 f.write(file_contents)
175 | 
176 |             # 成功メッセージ (絶対パスで表示すると分かりやすい)
177 |             print(f"ディレクトリリストが '{self.output_file.resolve()}' に出力されました。")
178 | 
179 |         except IOError as e:
180 |             # ファイル書き込みに関するエラー (ディスクフル、アクセス権など)
181 |             print(f"エラー: ファイル '{self.output_file}' に書き込めませんでした: {e}", file=sys.stderr)
182 |         except Exception as e:
183 |             # その他の予期せぬエラー
184 |             print(f"予期せぬエラーが発生しました: {e}", file=sys.stderr)
185 |     def run(self) -> None:
186 |         """
187 |         ディレクトリリスト化の全処理を実行する。
188 |         """
189 |         print(f"処理を開始します: {self.root_path}")
190 |         try:
191 |             # 1. ディレクトリ構造を生成
192 |             tree_structure = self.generate_tree_structure()
193 | 
194 |             # 2. ファイル内容を生成
195 |             file_contents = self.generate_file_contents()
196 | 
197 |             # 3. ファイルに書き込み
198 |             self.write_to_file(tree_structure, file_contents)
199 | 
200 |             print("処理が正常に完了しました。")
201 | 
202 |         except Exception as e:
203 |             # run の中で予期せぬエラーが起きた場合 (各メソッド内で捕捉されなかった場合など)
204 |             print(f"\n処理中にエラーが発生しました: {e}", file=sys.stderr)
205 |             # ここでプログラムを終了させるか、呼び出し元にエラーを伝えるかは設計による
206 |             # 今回は呼び出し元 (mainブロック) で最終的なエラーハンドリングを行う想定
207 |             raise # 捕捉したエラーを再度送出する
208 | 
209 | 
210 | def test_should_ignore(lister: DirectoryLister) -> None:
211 |     # テスト用のPathオブジェクトを作成 (Windows/Mac/Linuxで互換性のある書き方)
212 |     test_path_git = Path(".git") / "config" # 相対パスで作成
213 |     test_path_pycache = Path("my_module") / "__pycache__" / "cache_file.pyc"
214 |     test_path_dsstore = Path("images") / ".DS_Store"
215 |     test_path_log = Path("logs") / "app.log"
216 |     test_path_normal_file = Path("src") / "main.py"
217 |     test_path_normal_dir = Path("data")
218 |     test_path_root_ignored_file = Path(".env")
219 |     test_path_image = Path("assets") / "logo.png"
220 | 
221 |     print("-" * 20)
222 |     print("無視判定テスト:")
223 |     print(f"'{test_path_git}' は無視対象? -> {lister._should_ignore(test_path_git)}") # Trueのはず
224 |     print(f"'{test_path_pycache}' は無視対象? -> {lister._should_ignore(test_path_pycache)}") # Trueのはず
225 |     print(f"'{test_path_dsstore}' は無視対象? -> {lister._should_ignore(test_path_dsstore)}") # Trueのはず
226 |     print(f"'{test_path_log}' は無視対象? -> {lister._should_ignore(test_path_log)}") # Trueのはず
227 |     print(f"'{test_path_normal_file}' は無視対象? -> {lister._should_ignore(test_path_normal_file)}") # Falseのはず
228 |     print(f"'{test_path_normal_dir}' は無視対象? -> {lister._should_ignore(test_path_normal_dir)}") # Falseのはず
229 |     print(f"'{test_path_root_ignored_file}' は無視対象? -> {lister._should_ignore(test_path_root_ignored_file)}") # Trueのはず
230 |     print(f"'{test_path_image}' は無視対象? -> {lister._should_ignore(test_path_image)}") # Trueのはず
231 |     print("-" * 20)
232 | 
233 | 
234 | def test_get_sorted_items() -> None:
235 |     # テスト用のディレクトリとファイルを作成
236 |     test_base_dir = Path("./temp_lister_test")
237 |     test_base_dir.mkdir(exist_ok=True)
238 |     (test_base_dir / "dir_a").mkdir(exist_ok=True)
239 |     (test_base_dir / "file_z.txt").touch(exist_ok=True)
240 |     (test_base_dir / "File_B.py").touch(exist_ok=True)
241 |     (test_base_dir / "dir_c").mkdir(exist_ok=True)
242 |     (test_base_dir / ".env").touch(exist_ok=True) # 無視されるファイル
243 |     (test_base_dir / "image.png").touch(exist_ok=True) # 無視される拡張子
244 |     (test_base_dir / ".git").mkdir(exist_ok=True) # 無視されるディレクトリ
245 | 
246 |     # Listerインスタンスを作成 (テストディレクトリを対象)
247 |     lister = DirectoryLister(
248 |         Path(test_base_dir),
249 |         Path("./output.txt"),
250 |         config=get_config(Path('./settings.yml'))
251 |     )
252 | 
253 |     print(f"\n'{test_base_dir}' 内のソート済みアイテム:")
254 |     sorted_items = lister._get_sorted_items(test_base_dir)
255 |     if not sorted_items:
256 |         print("  (アイテムが見つからないか、アクセスエラー)")
257 |     for item in sorted_items:
258 |         item_type = "Dir " if item.is_dir() else "File"
259 |         print(f"  {item_type}: {item.name}")
260 | 
261 |     # 期待される出力順序の確認 (手動)
262 |     # dir_a, dir_c, File_B.py, file_z.txt の順になるはず
263 | 
264 | 
265 | def main() -> None:
266 | 
267 |     ROOT_DIR = Path(__file__).resolve().parent.parent.parent.parent.parent # プロジェクトのルートディレクトリを取得
268 | 
269 |     # インスタンス化
270 |     lister = DirectoryLister(
271 |         directory_path=Path(ROOT_DIR),
272 |         output_file=Path('./text.txt'),
273 |         config=get_config(Path('./ignore_settings.yml'))
274 |     )
275 | 
276 |     # ディレクトリリスト化を実行
277 |     lister.run()
278 | 
279 | 
280 |     # for item in a:
281 |     #     print(item)
282 | 
283 |     # test_should_ignore(lister)
284 |     # test_get_sorted_items()
285 | 
286 | 
287 | if __name__ == "__main__":
288 |     main()
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/ignore_config.py:
--------------------------------------------------------------------------------
 1 | import yaml
 2 | from pydantic import BaseModel
 3 | from typing import List
 4 | from pathlib import Path
 5 | 
 6 | class IgnoreExtensionsConfig(BaseModel):
 7 |     images: List[str] | None
 8 |     videos: List[str] | None
 9 |     compressed: List[str] | None
10 |     binaries: List[str] | None
11 |     documents: List[str] | None
12 |     others: List[str] | None
13 | 
14 |     def all_extensions(self) -> List[str]:
15 |         """全ての拡張子を取得する"""
16 |         all_exts = []
17 |         for attr in self.__dict__.values():
18 |             if isinstance(attr, list):
19 |                 all_exts.extend(attr)
20 |         return all_exts
21 | 
22 | 
23 | 
24 | class IgnoreConfig(BaseModel):
25 |     ignore_dirs: List[str] | None
26 |     ignore_files: List[str] | None
27 |     ignore_extensions: IgnoreExtensionsConfig | None
28 | 
29 | 
30 | def get_config(settings_yaml_path: Path)->IgnoreConfig:
31 |     with open(settings_yaml_path, 'rb') as f:
32 |         yml = yaml.safe_load(f)
33 | 
34 |     return IgnoreConfig.model_validate(yml)
35 | 
36 | 
37 | def main() -> None:
38 |     settings_yaml_path = Path('./ignore_settings.yml')
39 |     config = get_config(settings_yaml_path)
40 | 
41 |     print()
42 |     print(f"{getattr(config, 'ignore_dirs')=}")
43 |     print()
44 |     print(f"{getattr(config, 'ignore_extensions')=}")
45 |     print()
46 |     print(f"{getattr(config.ignore_extensions, 'images')=}")
47 |     print()
48 |     print(config.ignore_extensions.all_extensions())
49 |     print()
50 | 
51 | 
52 | if __name__ == "__main__":
53 |     main()
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/ignore_settings.yml:
--------------------------------------------------------------------------------
 1 | ignore_dirs:
 2 |   - ".git"
 3 |   - "__pycache__"
 4 |   - ".venv"
 5 |   - "node_modules"
 6 |   - ".vscode"
 7 |   - ".idea"
 8 |   - "build"
 9 |   - "dist"
10 |   - "*.egg_info"
11 |   - ".mypy_cache"
12 | ignore_files:
13 |   - ".DS_Store"
14 |   - ".env"
15 |   - "thumbs.db"
16 |   - "settings.yml"
17 | ignore_extensions:
18 |   images:
19 |     - '.png'
20 |     - '.jpg'
21 |     - '.jpeg'
22 |     - '.gif'
23 |     - '.bmp'
24 |     - '.tiff'
25 |     - '.webp'
26 |     - '.svg'
27 |     - '.ico'
28 |   videos:
29 |     - '.mp4'
30 |     - '.mov'
31 |     - '.avi'
32 |     - '.wmv'
33 |     - '.mp3'
34 |     - '.wav'
35 |     - '.ogg'
36 |   compressed:
37 |     - '.zip'
38 |     - '.gz'
39 |     - '.tar'
40 |     - '.rar'
41 |     - '.7z'
42 |   binaries:
43 |     - '.pyc'
44 |     - '.pyo'
45 |     - '.exe'
46 |     - '.dll'
47 |     - '.so'
48 |     - '.o'
49 |     - '.a'
50 |     - '.lib'
51 |   documents:
52 |     - '.pdf'
53 |     - '.doc'
54 |     - '.docx'
55 |     - '.xls'
56 |     - '.xlsx'
57 |     - '.ppt'
58 |     - '.pptx'
59 |   others:
60 |     - '.lock'
61 |     - '.log'
62 |     - '.sqlite'
63 |     - '.db'
64 | 
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/temp_lister_test/File_B.py:
--------------------------------------------------------------------------------
 [空ファイル]
--------------------------------------------------------------------------------


/project_module/src/project_module/directory_lister/temp_lister_test/file_z.txt:
--------------------------------------------------------------------------------
 [空ファイル]
--------------------------------------------------------------------------------


/pyproject.toml:
--------------------------------------------------------------------------------
 1 | [project]
 2 | name = "repository-reader"
 3 | version = "0.1.0"
 4 | description = ""
 5 | authors = [
 6 |     {name = "Your Name",email = "you@example.com"}
 7 | ]
 8 | readme = "README.md"
 9 | requires-python = ">=3.11,<4.0"
10 | dependencies = [
11 |     "pyyaml (>=6.0.2,<7.0.0)",
12 |     "pydantic (>=2.11.3,<3.0.0)",
13 |     "langchain-google-genai (>=2.1.3,<3.0.0)",
14 |     "python-dotenv (>=1.1.0,<2.0.0)"
15 | ]
16 | 
17 | [tool.poetry]
18 | package-mode = false
19 | 
20 | 
21 | [build-system]
22 | requires = ["poetry-core>=2.0.0,<3.0.0"]
23 | build-backend = "poetry.core.masonry.api"
--------------------------------------------------------------------------------


/README.md:
--------------------------------------------------------------------------------
1 | ## repository reader
--------------------------------------------------------------------------------


/Taskfile.yaml:
--------------------------------------------------------------------------------
 1 | version: '3'
 2 | 
 3 | dotenv: ['.env']
 4 | 
 5 | tasks:
 6 |   build:
 7 |     desc: Dockerイメージのビルド
 8 |     cmds:
 9 |       - docker compose -f ./context/cpu/docker-compose.yaml build
10 | 
11 |   up:
12 |     desc: コンテナを起動
13 |     cmds:
14 |       - docker compose -f ./context/cpu/docker-compose.yaml up -d
15 | 
16 |   down:
17 |     desc: コンテナの停止と削除
18 |     cmds:
19 |       - docker compose -f ./context/cpu/docker-compose.yaml down
20 | 
21 |   write_uid_onto_env:
22 |     desc: ホストマシンのUIDとUSERNAMEを.envに書き込む
23 |     cmds:
24 |       - |
25 |         TEMP_FILE=$(mktemp)
26 |         grep -v "^USER_UID=" .env | grep -v "^USERNAME=" > $$TEMP_FILE
27 |         echo "USER_UID=$(id -u $(whoami))" >> $$TEMP_FILE
28 |         echo "USERNAME=$USER" >> $$TEMP_FILE
29 |         mv $$TEMP_FILE .env
30 | 
31 |   shell:
32 |     desc: UID書き込み -> build -> up -> コンテナに入る
33 |     cmds:
34 |       - task: write_uid_onto_env
35 |       - task: build
36 |       - task: up
37 |       - docker exec -it "{{.container_name}}" /bin/bash
38 |     vars:
39 |       container_name:
40 |         sh: 'echo ${CONTAINER_NAME}'
--------------------------------------------------------------------------------
